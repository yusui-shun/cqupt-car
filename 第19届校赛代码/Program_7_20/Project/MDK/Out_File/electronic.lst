C251 COMPILER V5.60.0,  electronic                                                         18/11/23  13:17:09  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE electronic
OBJECT MODULE PLACED IN .\Out_File\electronic.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\CODE\electronic.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\electronic.lst) TABS(2) OBJECT(.\Out_File\electronic.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          #include "electronic.h"
    3          
    4          #define count 10
    5          
    6          //é‡‡æ ·512ä¸ªç‚¹
    7          //å·®æ¯”å’ŒåŠ æƒç³»æ•°
    8          float weightA=1, weightB=1;
    9          float Limit=1;//é™å¹…ç³»æ•°
   10          float electro_error = 0;        // å·¦æ¨ªå³æ¨ªå·®æ¯”å’Œ
   11          
   12          int8 Turn_flag = 0;
   13          //int16 L0=0,L1=0,L2=0,R0=0,R1=0,R2=0;
   14          int16 MagneticField=0;//ç£åœºæ•´ä½“å¼ºåº¦
   15          //int16 left = 0,middle = 0, right = 0;  // ç”µæ„Ÿåç§»é‡
   16          int16 LnowADC[6] = {0,0,0,0,0,0};           // ç”µæ„Ÿå½“å‰ADCæ•°å€¼
   17          //int16 ad_max_heng,ad_max_shu,ad_max_xie;            //æ¯ä¸ªæ–°èµ›é“éƒ½éœ€è¦é‡æ–°æ ‡å®šæœ€å¤§å€¼å’Œæœ€å°
             -å€¼
   18          //int16 ad_min_heng,ad_min_shu,ad_min_xie;  
   19          
   20          int16 ADC_DATA_CH0[6];   // å·¦æ¨ªé‡‡æ ·æ•°ç»„
   21          int16 ADC_DATA_CH5[6];   // å³æ¨ªé‡‡æ ·æ•°ç»„
   22          
   23          int16 ADC_DATA_CH2[6];   // ä¸­æ¨ªé‡‡æ ·æ•°ç»„
   24          
   25          int16 ADC_DATA_CH1[6];   // å·¦ç«–é‡‡æ ·æ•°ç»„
   26          int16 ADC_DATA_CH4[6];   // å³ç«–é‡‡æ ·æ•°ç»„
   27          
   28          
   29          void adc_data_convert(void);
   30          uint16 adc_filter(int16 *a);
   31          
   32          
   33          /**************6è·¯ç”µç£åˆå§‹åŒ–å‡½æ•°*******
   34           * å‡½æ•°åç§°  ADC_6_road_init
   35           * å…¥å£å‚æ•°  void
   36           * è¾“å‡ºå‚æ•°  void
   37           */
   38          void ADC_6_road_init()
   39          {
   40   1          adc_init(ADC0, ADC_SYSclk_DIV_2);
   41   1          adc_init(ADC1, ADC_SYSclk_DIV_2);
   42   1          adc_init(ADC2, ADC_SYSclk_DIV_2);
   43   1          adc_init(ADC3, ADC_SYSclk_DIV_2);
   44   1          adc_init(ADC4, ADC_SYSclk_DIV_2);
   45   1          adc_init(ADC5, ADC_SYSclk_DIV_2);
   46   1      }
   47          /*************************************************************************
   48           *  å‡½æ•°åç§°ï¼švoid InductorNormal(void)
   49           *  åŠŸèƒ½è¯´æ˜ï¼šé‡‡é›†ç”µæ„Ÿç”µå‹å¹¶å½’ä¸€åŒ–ï¼›
   50           *  å‚æ•°è¯´æ˜ï¼šæ—  ,
   51           *  å‡½æ•°è¿”å›ï¼šæ— 
   52           *  ä¿®æ”¹æ—¶é—´ï¼š2020å¹´11æœˆ18æ—¥
   53           *  å¤‡    æ³¨ï¼š   æ³¨æ„è¦å…ˆæ ‡å®šè¿æ”¾çš„æ”¾å¤§å€æ•°
   54           *************************************************************************/
   55          void InductorNormal(void)
   56          {
C251 COMPILER V5.60.0,  electronic                                                         18/11/23  13:17:09  PAGE 2   

   57   1          adc_data_convert();
   58   1          LnowADC[0] =  adc_filter(ADC_DATA_CH0);    // å·¦æ¨ª
   59   1          LnowADC[5] =  adc_filter(ADC_DATA_CH5);    // å³æ¨ª
   60   1          LnowADC[2] =  adc_filter(ADC_DATA_CH2);    // ä¸­æ¨ª
   61   1        
   62   1          LnowADC[1] =  adc_filter(ADC_DATA_CH1);    // å·¦ç«–
   63   1          LnowADC[4] =  adc_filter(ADC_DATA_CH4);    // å³ç«–
   64   1        
   65   1          MagneticField = LnowADC[0] + LnowADC[5];//ç£åœºæ•´ä½“å¼ºåº¦
   66   1          electro_error =
   67   1                  (weightA*(LnowADC[0] - LnowADC[5]))*Limit
   68   1                  /
   69   1                  (weightA*(LnowADC[0] + LnowADC[5])+1);
   70   1          electro_error *= 100;
   71   1          Turn_flag=1;
   72   1        }
   73          //-------------------------------------------------------------------------------------------------------
             -------------
   74          // å‡½æ•°ç®€ä»‹     ADC å‡å€¼æ»¤æ³¢è½¬æ¢
   75          // å‚æ•°è¯´æ˜     ch              é€‰æ‹© ADC é€šé“ (è¯¦è§ zf_driver_adc.h ä¸­æšä¸¾ adc_channel_enum 
             -å®šä¹‰)
   76          // å‚æ•°è¯´æ˜     count           å‡å€¼æ»¤æ³¢æ¬¡æ•°
   77          // è¿”å›å‚æ•°     uint16          è½¬æ¢çš„ ADC å€¼
   78          // ä½¿ç”¨ç¤ºä¾‹     adc_mean_filter_convert(ADC1_CH0_A0, 5);                        // é‡‡é›†5æ¬¡å»æ‰æœ
             -€å¤§å’Œæœ€å°å€¼ ç„¶åè¿”å›å¹³å‡å€¼
   79          // å¤‡æ³¨ä¿¡æ¯
   80          //-------------------------------------------------------------------------------------------------------
             -------------
   81          uint16 adc_mean_filter_convert(ADCN_enum vadc_chn)
   82          {
   83   1          uint8 xdata i;
   84   1          int16 xdata a[count+2],filter_temp,out=0,j;
   85   1        //é‡‡é›†ç”µæ„Ÿ
   86   1        for(i=0;i<count+2;i++)
   87   1        {
   88   2        a[i] = adc_once(vadc_chn, ADC_10BIT);
   89   2        }
   90   1        //å†’æ³¡æ’åˆ—
   91   1        for(j = 0; j < count+1; j++)
   92   1          {
   93   2              for(i = 0; i < count+1 - j; i++)
   94   2              {
   95   3                  if(a[i] > a[i + 1])
   96   3                  {
   97   4                      filter_temp = a[i];
   98   4                      a[i] = a[i + 1];
   99   4                      a[i + 1] = filter_temp;
  100   4                  }
  101   3              }
  102   2          }
  103   1        //å»æ‰æœ€å¤§ä»¥åŠæœ€å°å€¼
  104   1          for(i = 1; i < count+1; i++)
  105   1          {
  106   2            out += a[i];
  107   2          } 
  108   1        //å–å¹³å‡å€¼
  109   1          out = out / count ;
  110   1          return (uint16)out;
  111   1      }
  112          
  113          
  114          
  115          
  116          void adc_data_convert(void)
  117          {
  118   1        uint8 xdata i;
C251 COMPILER V5.60.0,  electronic                                                         18/11/23  13:17:09  PAGE 3   

  119   1        
  120   1        for(i=0; i<6; i++)
  121   1        {
  122   2          ADC_DATA_CH0[i] = adc_once(ADC0,ADC_10BIT);      // å·¦æ¨ª
  123   2          ADC_DATA_CH5[i] = adc_once(ADC5,ADC_10BIT);      // å³æ¨ª
  124   2      
  125   2          ADC_DATA_CH2[i] = adc_once(ADC2,ADC_10BIT);      // ä¸­æ¨ª
  126   2      //    ADC_DATA_CH3[i] = adc_once(ADC3,ADC_10BIT);      // å³æ–œ
  127   2          
  128   2          ADC_DATA_CH1[i] = adc_once(ADC1,ADC_10BIT);      // å·¦ç«–
  129   2          ADC_DATA_CH4[i] = adc_once(ADC4,ADC_10BIT);      // å³ç«–
  130   2        }
  131   1      }
  132          
  133          
  134          uint16 adc_filter(int16 *a)
  135          {
  136   1          uint8 xdata i;
  137   1          int16 xdata out=0;
  138   1          
  139   1          for(i=0; i<6; i++)
  140   1          {
  141   2            out += a[i];
  142   2          }
  143   1          
  144   1          out = 0.1666 * out;
  145   1          
  146   1          return (int16)out;
  147   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       937     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        29     ------
  xdata-const size     =    ------     ------
  edata size           =       103     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        59     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
